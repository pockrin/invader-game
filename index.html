<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Invader - Elegant Palette</title>
  <style>
    :root{
      --bg:#0F1217;
      --bg2:#0B0E13;
      --player:#E2E8F0;
      --enemy:#7DD3FC;
      --enemy-strong:#A78BFA;
      --bullet-player:#FDE68A;
      --bullet-enemy:#FCA5A5;
      --text:#CBD5E1;
      --flash:#F472B6;
      --panel:#1F2937;
      --panel-border:#334155;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", "Yu Gothic UI", "Yu Gothic", Meiryo, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .wrap {
      display: grid;
      place-items: center;
      height: 100%;
      gap: 12px;
    }
    canvas {
      display: block;
      background: transparent;
      image-rendering: pixelated; /* レトロ感を保ちつつシャープに */
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
      border-radius: 10px;
    }
    .panel {
      display: flex; gap: 10px; align-items: center; justify-content: center;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      padding: 8px 14px;
      color: #E5E7EB;
      font-size: 14px;
    }
    .kbd {
      padding: 2px 6px;
      border: 1px solid #64748B;
      border-bottom-width: 2px;
      border-radius: 6px;
      background: #0B1220;
      color: #D1D5DB;
      font-variant-numeric: tabular-nums;
    }
    a { color: #93C5FD; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="640" height="480" aria-label="Invader Game"></canvas>
    <div class="panel">
      <span>← → 移動</span>
      <span class="kbd">Space</span><span>射撃</span>
      <span class="kbd">R</span><span>リスタート</span>
    </div>
  </div>

  <script>
    // 配色
    const Colors = {
      bg: getCssVar('--bg'),
      bg2: getCssVar('--bg2'),
      player: getCssVar('--player'),
      enemy: getCssVar('--enemy'),
      enemyStrong: getCssVar('--enemy-strong'),
      bulletPlayer: getCssVar('--bullet-player'),
      bulletEnemy: getCssVar('--bullet-enemy'),
      text: getCssVar('--text'),
      flash: getCssVar('--flash')
    };
    function getCssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    // 基本セットアップ
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const W = canvas.width;
    const H = canvas.height;

    // 入力状態
    const Keys = { left:false, right:false, fire:false, restart:false };
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'ArrowLeft') Keys.left = true;
      if (e.code === 'ArrowRight') Keys.right = true;
      if (e.code === 'Space') Keys.fire = true;
      if (e.code === 'KeyR') Keys.restart = true;
    });
    window.addEventListener('keyup', (e)=>{
      if (e.code === 'ArrowLeft') Keys.left = false;
      if (e.code === 'ArrowRight') Keys.right = false;
      if (e.code === 'Space') Keys.fire = false;
      if (e.code === 'KeyR') Keys.restart = false;
    });

    // 乱数ヘルパ
    const rand = (a,b)=> a + Math.random()*(b-a);

    // ゲーム状態
    const state = {
      scene: 'title', // 'title' | 'play' | 'gameover' | 'clear'
      score: 0,
      lives: 3,
      wave: 1,
      flashTimer: 0,
      lastFireTime: 0,
      fireCooldown: 220, // ms
      shake: 0
    };

    // プレイヤー
    const player = {
      x: W/2, y: H-50, w: 36, h: 12, speed: 220,
      alive: true, hitTimer: 0
    };

    // 弾
    const bullets = []; // {x,y,r,vy,from:'player'|'enemy'}
    // 敵
    let enemies = [];   // {x,y,w,h,alive,strong,dx}
    // 爆発パーティクル
    const sparks = [];  // {x,y,dx,dy,life,color}

    // 初期化
    function resetGame(){
      state.scene = 'title';
      state.score = 0;
      state.lives = 3;
      state.wave = 1;
      player.x = W/2; player.y = H-50; player.alive = true;
      bullets.length = 0;
      sparks.length = 0;
      spawnEnemies(state.wave);
    }

    function spawnEnemies(wave){
      enemies = [];
      const rows = 5, cols = 10;
      const cellW = 48, cellH = 32;
      const startX = (W - (cols-1)*cellW)/2 - 16;
      const startY = 80;
      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          const strong = (r < 2) || (Math.random() < 0.1*wave);
          enemies.push({
            x: startX + c*cellW,
            y: startY + r*cellH,
            w: 26, h: 16,
            alive: true,
            strong,
            dx: 40 + wave*5
          });
        }
      }
    }

    // 背景
    function drawBackground(){
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, Colors.bg);
      g.addColorStop(1, Colors.bg2);
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      // 微細ノイズ
      ctx.save();
      ctx.globalAlpha = 0.05;
      ctx.fillStyle = '#FFFFFF';
      for (let i=0;i<50;i++){
        const x = Math.random()*W, y = Math.random()*H, s = Math.random()*2;
        ctx.fillRect(x, y, s, s);
      }
      ctx.restore();
    }

    // プレイヤー描画
    function drawPlayer(){
      ctx.save();
      if (player.hitTimer > 0){
        ctx.globalAlpha = 0.6 + 0.4*Math.sin(Date.now()*0.04);
        ctx.fillStyle = Colors.flash;
      } else {
        ctx.fillStyle = Colors.player;
      }
      roundRect(ctx, player.x-player.w/2, player.y-player.h/2, player.w, player.h, 3, true);
      // ライトグロー
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = Colors.player;
      roundRect(ctx, player.x-player.w/2, player.y-player.h/2-4, player.w, player.h, 6, true);
      ctx.restore();
    }

    // 敵描画
    function drawEnemy(e){
      ctx.save();
      ctx.fillStyle = e.strong ? Colors.enemyStrong : Colors.enemy;
      const t = Date.now()*0.005;
      const pulse = 0.8 + 0.2*Math.sin(t + (e.x+e.y)*0.01);
      ctx.globalAlpha = pulse;
      roundRect(ctx, e.x-e.w/2, e.y-e.h/2, e.w, e.h, 3, true);
      ctx.restore();
    }

    // 弾描画
    function drawBullet(b){
      ctx.save();
      ctx.fillStyle = b.from === 'player' ? Colors.bulletPlayer : Colors.bulletEnemy;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      // 外側グロー
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r+3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // UI
    function drawUI(){
      ctx.save();
      ctx.fillStyle = Colors.text;
      ctx.font = '16px Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif';
      ctx.fillText(`SCORE ${state.score}`, 12, 24);
      ctx.fillText(`LIVES ${state.lives}`, 120, 24);
      ctx.fillText(`WAVE ${state.wave}`, 220, 24);
      ctx.restore();
    }

    // タイトル/メッセージ
    function drawCenteredMessage(title, subtitle){
      ctx.save();
      ctx.fillStyle = Colors.text;
      ctx.textAlign = 'center';
      ctx.font = '700 28px Inter, ui-sans-serif, system-ui';
      ctx.fillText(title, W/2, H/2 - 10);
      ctx.font = '14px Inter, ui-sans-serif, system-ui';
      ctx.fillText(subtitle, W/2, H/2 + 18);
      ctx.restore();
    }

    // 角丸矩形
    function roundRect(ctx, x, y, w, h, r, fill=true, stroke=false){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // 爆発スパーク
    function addExplosion(x,y,color){
      for (let i=0;i<16;i++){
        sparks.push({
          x, y,
          dx: rand(-80,80),
          dy: rand(-120, -20),
          life: rand(0.25, 0.7),
          color
        });
      }
      state.shake = Math.max(state.shake, 6);
    }

    function updateSparks(dt){
      for (let i=sparks.length-1;i>=0;i--){
        const s = sparks[i];
        s.life -= dt;
        if (s.life <= 0){ sparks.splice(i,1); continue; }
        s.x += s.dx * dt;
        s.y += s.dy * dt;
        s.dy += 200*dt; // gravity
      }
    }
    function drawSparks(){
      ctx.save();
      for (const s of sparks){
        ctx.globalAlpha = Math.max(0, s.life);
        ctx.fillStyle = s.color;
        ctx.fillRect(s.x, s.y, 2, 2);
      }
      ctx.restore();
    }

    // 当たり判定
    function aabb(ax,ay,aw,ah, bx,by,bw,bh){
      return (Math.abs(ax-bx) * 2 < (aw + bw)) && (Math.abs(ay-by) * 2 < (ah + bh));
    }

    // ゲーム更新
    let lastTime = performance.now();
    resetGame();

    function gameLoop(now){
      const dt = Math.min(0.033, (now - lastTime)/1000);
      lastTime = now;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    function update(dt){
      if (state.scene === 'title'){
        if (Keys.fire || Keys.left || Keys.right){
          state.scene = 'play';
        }
      } else if (state.scene === 'play'){
        // プレイヤー移動
        const dir = (Keys.right?1:0) - (Keys.left?1:0);
        player.x += dir * player.speed * dt;
        player.x = Math.max(24, Math.min(W-24, player.x));

        // 射撃
        if (Keys.fire && (nowMs() - state.lastFireTime >= state.fireCooldown)){
          bullets.push({ x: player.x, y: player.y-10, r: 3, vy: -360, from: 'player' });
          state.lastFireTime = nowMs();
        }

        // 敵の移動と射撃
        let edgeHit = false;
        for (const e of enemies){
          if (!e.alive) continue;
          e.x += e.dx * dt;
          if (e.x < 24 || e.x > W-24){ edgeHit = true; }
          // 敵射撃（低確率、下の列ほど発射）
          if (Math.random() < 0.0025){
            bullets.push({ x: e.x, y: e.y+12, r: 3, vy: 140 + Math.random()*60, from: 'enemy' });
          }
          // 侵攻しすぎたらゲームオーバー
          if (e.y > H-100){
            state.scene = 'gameover';
          }
        }
        if (edgeHit){
          for (const e of enemies){
            e.dx *= -1;
            e.y += 10;
          }
        }

        // 弾更新
        for (let i=bullets.length-1;i>=0;i--){
          const b = bullets[i];
          b.y += b.vy * dt;
          if (b.y < -10 || b.y > H+10){
            bullets.splice(i,1); continue;
          }
        }

        // 衝突: プレイヤー弾 vs 敵
        for (let i=bullets.length-1;i>=0;i--){
          const b = bullets[i];
          if (b.from !== 'player') continue;
          for (const e of enemies){
            if (!e.alive) continue;
            if (Math.abs(b.x - e.x) < e.w/2 + b.r && Math.abs(b.y - e.y) < e.h/2 + b.r){
              e.alive = false;
              bullets.splice(i,1);
              const col = e.strong ? Colors.enemyStrong : Colors.enemy;
              addExplosion(e.x, e.y, col);
              state.score += e.strong ? 150 : 100;
              break;
            }
          }
        }

        // 衝突: 敵弾 vs プレイヤー
        if (player.alive){
          for (let i=bullets.length-1;i>=0;i--){
            const b = bullets[i];
            if (b.from !== 'enemy') continue;
            if (Math.abs(b.x - player.x) < player.w/2 + b.r && Math.abs(b.y - player.y) < player.h/2 + b.r){
              bullets.splice(i,1);
              player.hitTimer = 0.4;
              state.lives--;
              addExplosion(player.x, player.y-6, Colors.flash);
              if (state.lives <= 0){
                state.scene = 'gameover';
                player.alive = false;
              }
              break;
            }
          }
        }

        // 残敵チェック
        if (enemies.every(e => !e.alive)){
          state.wave++;
          spawnEnemies(state.wave);
          // クリア演出
          state.scene = 'clear';
          setTimeout(()=>{ state.scene = 'play'; }, 900);
        }

        // タイマー等
        if (player.hitTimer > 0) player.hitTimer -= dt;
        if (state.flashTimer > 0) state.flashTimer -= dt;

        // 画面シェイク減衰
        state.shake = Math.max(0, state.shake - 30*dt);

        // パーティクル
        updateSparks(dt);

      } else if (state.scene === 'gameover'){
        if (Keys.restart){
          resetGame();
          state.scene = 'play';
        }
      } else if (state.scene === 'clear'){
        // 軽くスローモーション演出
        updateSparks(dt);
      }
    }

    function draw(){
      // 画面揺れ
      const sx = rand(-state.shake, state.shake);
      const sy = rand(-state.shake, state.shake);

      drawBackground();

      ctx.save();
      ctx.translate(sx, sy);

      if (state.scene === 'title'){
        drawUI();
        drawCenteredMessage('INVADER', 'Spaceで開始 / ← →で移動');
        // タイトルでも編隊を見せる
        for (const e of enemies){ if (e.alive) drawEnemy(e); }
        drawPlayer();
        drawSparks();
      } else if (state.scene === 'play' || state.scene === 'clear'){
        drawUI();
        for (const e of enemies){ if (e.alive) drawEnemy(e); }
        for (const b of bullets) drawBullet(b);
        drawPlayer();
        drawSparks();

        if (state.scene === 'clear'){
          ctx.save();
          ctx.globalAlpha = 0.85;
          drawCenteredMessage('WAVE CLEAR', '次のウェーブに進みます');
          ctx.restore();
        }
      } else if (state.scene === 'gameover'){
        drawUI();
        for (const e of enemies){ if (e.alive) drawEnemy(e); }
        for (const b of bullets) drawBullet(b);
        drawPlayer();
        drawSparks();
        ctx.save();
        ctx.globalAlpha = 0.9;
        drawCenteredMessage('GAME OVER', 'Rでリスタート');
        ctx.restore();
      }

      ctx.restore();
    }

    function nowMs(){ return performance.now(); }

    // ===== 設定を変えたい場合 =====
    // 1) 画面サイズ: <canvas> の width/height を変更し、プレイヤー初期Yや境界も合わせて調整
    // 2) 弾の発射間隔: state.fireCooldown
    // 3) 敵の列数/列幅: spawnEnemies内の rows, cols, cellW, cellH
    // 4) パステル調を強めたい: CSSの --enemy, --enemy-strong, --bullet-* を淡い色に
  </script>
</body>
</html>
